function splashScreen(){

	var canvas = document.getElementById("gameCanvas");
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
	var ctx = canvas.getContext("2d");
	var splashImage = new Image();
	splashImage.src = "fallingsplash.jpg";
	var barImage = new Image();
	$("#startGame").on('touchstart', function(){
		loadImage();
	});

	var thumbImg = document.createElement('img');
	//thumbImg.src = 'gratiicoin50.png';
	thumbImg.src = 'gratiiCoinIconGolden1.png';
	
function loadImage(){
	$('#splashScreen').hide();
	barImage.src = "bar.jpg";
	ctx.clearRect(0,0,canvas.width,canvas.height);
	canvas.removeEventListener('touchstart', loadImage, false);
	barImage.addEventListener('load', fallingGame, false);
}

function fallingGame(){

	var gameID;
	var intervalVal;
	var lastTouch = null;
	var currentOrientation = window.orientation;

	function Timer(){
		this.gameTime = 0;
		this.maxStep = 0.05;
		this.wallLastTimestamp = 0;
	}

	Timer.prototype.tick = function(){
		var wallCurrent = Date.now();
		var wallDelta = (wallCurrent - this.wallLastTimestamp)/1000;
		this.wallLastTimestamp = wallCurrent;

		var gameDelta = Math.min(wallDelta, this.maxStep);
		this.gameTime += gameDelta;
		return gameDelta;
	}

	var timer = new Timer();
	var clockTick;

	var gameToken = "X1X2X3X";

	//Constants -----------------------------------------------------

	var SCALING_CONSTANT = 0.4*60;

	//the boundaries of the stage, in pixels
	var FRAME_LEFT = 0;
	var FRAME_RIGHT = canvas.width;
	var FRAME_TOP = 0;
	var FRAME_BOTTOM = canvas.height;

	var PLAYER_RADIUS = 15;
	var PLAYER_SPEED = 13;
	var GRAVITY = 2;

	var BASE_BAR_SPEED = 6;
	var BAR_SPEED_INCREASE_RATE = 1/(24*20);
	var MAX_BAR_SPEED = 20;

	var BAR_WIDTH = canvas.width;
	var BAR_HEIGHT = 20;
	var NUM_BARS = 5;

	//change these constants to tweak how the gaps are generated.
	var MIN_GAP_WIDTH = PLAYER_RADIUS*3;
	var MAX_GAP_WIDTH = PLAYER_RADIUS*6;
	var MAX_GAPS_PER_BAR = 3;
	var MIN_GAP_DISTANCE = MIN_GAP_WIDTH; // the minimum distance between any 2 gaps.
	//if this is increased, then it is less likely that there will be multiple gaps per bar.
	//also limits the maximum gaps per bar.

	//initializing variables -----------------------------------------
	var gameOver = false;
	var elapsedFrames = 0; // use this to scale the bar speed, as well as determine gratii

	var barSpeed = BASE_BAR_SPEED; //speed at which the "bars" move up

	var player = {
		_x: (FRAME_LEFT + FRAME_RIGHT)/2,
		_y: FRAME_TOP + PLAYER_RADIUS,
		y_velocity: 0,
		y_acceleration: GRAVITY
	};

	var bars = new Array();

		//create the bar objects
	var increment = canvas.height/(NUM_BARS-1);
	for(var i = 0; i < NUM_BARS; i++){
		bars[i] = {
			_x: FRAME_LEFT,
			_y: i*increment + FRAME_TOP + canvas.height/2,
			gaps: null
		};
		generateGaps(bars[i]);
	}
	var bottomBarIndex = NUM_BARS - 1;


// gap generation ------------------------------------------------

	function generateGaps(bar){
		bar.gaps = new Array();

		/* add some number of gaps to the bar (between 1 and MAX_GAPS_PER_BAR).
		 * if the new gap generated by newGap() conflicts with one of the existing gaps,
		 * it is not added, so the result is a random number of gaps per bar, with more gaps
		 * being less likely.
		 */
		for(var i = 0; i < MAX_GAPS_PER_BAR; i++)
			addGap(bar, newGap());
		//console.log(bar.gaps.length);
	}

	/* adds the newGap object to the bar object's gaps array.
	 * if there exists a conflict with one of the existing gaps, it is not added.
	 * currently, a conflict is defined as two gaps being within MIN_GAP_DISTANCE of each other.
	 */
	function addGap(bar, newGap){

		var insertIndex = -1;

		for(var i = 0; i < bar.gaps.length; i++){
			var invalidStartPos = bar.gaps[i].startPos - MIN_GAP_DISTANCE;
			var invalidEndPos = bar.gaps[i].endPos + MIN_GAP_DISTANCE;

			if(intersects(newGap.startPos, newGap.endPos, invalidStartPos, invalidEndPos))
				return;

			if(newGap.startPos < bar.gaps[i].startPos){
				insertIndex = i;
				break;
			}
		}
		if(insertIndex == -1)
			insertIndex = bar.gaps.length;

		bar.gaps.splice(insertIndex, 0, newGap);
	}

	//utility function, returns true of the two intervals intersect
	function intersects(start1, end1, start2, end2){
		if(start1 >= start2 && start1 <= end2 ||
		   end1 >= start2 && end1 <= end2)
		   return true;
		return false;
	}

	//gap object constructor
	function gap(startPos, endPos){
		this.startPos = startPos;
		this.endPos = endPos;
	}

	//makes a new gap at a random starting location and of random length
	function newGap(){
		var newStartPos = Math.floor(Math.random()*(canvas.width - MIN_GAP_WIDTH));
		var newEndPos = Math.floor(Math.random()*(MAX_GAP_WIDTH - MIN_GAP_WIDTH + 1)) + MIN_GAP_WIDTH + newStartPos;
		if(newEndPos > canvas.width)
			newEndPos = canvas.width;

		gapObj = new gap(newStartPos, newEndPos);

		return gapObj;
	}

	//orientation -------------------------------------------------------------

	window.onorientationchange = function(){
		//console.log("orientation change: " + window.orientation);
		currentOrientation = window.orientation;
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;
	};

	//handle keyboard controls -------------------------------------------------------------
	var keysDown = {};

	addEventListener("keydown", function (e) {
		keysDown[e.keyCode] = true;
	}, false);

	addEventListener("keyup", function (e) {
		delete keysDown[e.keyCode];
	}, false);

	//mouse controls
	canvas.addEventListener("touchstart", function (e) {
		e.preventDefault();
		var offsets = canvas.getBoundingClientRect();

		if(e.changedTouches.length == 1){
			var touch = e.changedTouches[0];
			var xPos = touch.clientX - offsets.left;
			var yPos = touch.clientY - offsets.top;
			if(lastTouch != null){
				var oldX = lastTouch.clientX - offsets.left;
				//console.log("last touch X at " + oldX);
				//correct the x position
				xPos = 2*xPos - oldX;
			}
			//console.log("touchstart at " + xPos + " " + yPos);

			if(xPos < canvas.width/2){
				delete keysDown[39];
				keysDown[37] = true;
			}
			if(xPos > canvas.width/2){
				keysDown[39] = true;
				delete keysDown[37];
			}
			lastTouch = e.changedTouches[0];
		}
	}, false);

	canvas.addEventListener("touchend", function (e) {
		e.preventDefault();
		var offsets = canvas.getBoundingClientRect();

		if(e.changedTouches.length == 1){
			var touch = e.changedTouches[0];
			var xPos = touch.clientX - offsets.left;
			var yPos = touch.clientY - offsets.top;
			//console.log("touchend at " + xPos + " " + yPos);

/*			if(xPos < canvas.width/2)
				delete keysDown[37];
			if(xPos > canvas.width/2)
				delete keysDown[39];*/
			keysDown = {};

		}
		lastTouch = null;
	}, false);
	/*
	$('#gameCanvas').bind("taphold", function (e) {
		var offsets = canvas.getBoundingClientRect();
		var xPos = e.clientX - offsets.left;
		var yPos = e.clientY - offsets.top;
		//console.log("mousedown at " + xPos + " " + yPos);

		if(xPos < canvas.width/2)
			keysDown[37] = true;
		if(xPos > canvas.width/2)
			keysDown[39] = true;
	});

	$('#gameCanvas').bind("taphold", function (e) {
		var offsets = canvas.getBoundingClientRect();
		var xPos = e.clientX - offsets.left;
		var yPos = e.clientY - offsets.top;
		//console.log("mouseup at " + xPos + " " + yPos);

		if(xPos < canvas.width/2)
			delete keysDown[37];
		if(xPos > canvas.width/2)
			delete keysDown[39];
	});*/

	function keyInput(){
		if (37 in keysDown) { // Player holding left
			player._x -= PLAYER_SPEED*SCALING_CONSTANT*clockTick;
		}
		if (39 in keysDown) { // Player holding right
			player._x += PLAYER_SPEED*SCALING_CONSTANT*clockTick;
		}
		boundaryCollisions();

		//this enormous ugly loop handles collisions for if the player bumps into
		//the side of a gap from inside it
		for(var i = 0; i < NUM_BARS; i++){
			//this if statement checks if the player's Y position overlaps with the Y positions
			//of the bar.
			if(player._y - PLAYER_RADIUS > bars[i]._y && player._y - PLAYER_RADIUS < bars[i]._y + BAR_HEIGHT ||
			   bars[i]._y > player._y - PLAYER_RADIUS && bars[i]._y < player._y + PLAYER_RADIUS){
				for(var j = 0; j < bars[i].gaps.length; j++){

					//if the player intersects with a gap, keep it within the gap
					if(intersects(player._x - PLAYER_RADIUS - FRAME_LEFT,
								   player._x + PLAYER_RADIUS - FRAME_LEFT,
								   bars[i].gaps[j].startPos,
								   bars[i].gaps[j].endPos))
					{
						if(player._x - PLAYER_RADIUS - FRAME_LEFT < bars[i].gaps[j].startPos)
							player._x = bars[i].gaps[j].startPos + FRAME_LEFT + PLAYER_RADIUS;
						if(player._x + PLAYER_RADIUS - FRAME_LEFT > bars[i].gaps[j].endPos)
							player._x = bars[i].gaps[j].endPos + FRAME_LEFT - PLAYER_RADIUS;
					}
				}
			}
		}
	}

	//handles collisions with the sides of the screen
	function boundaryCollisions(){
		if(player._x - PLAYER_RADIUS < FRAME_LEFT)
			player._x = FRAME_LEFT + PLAYER_RADIUS;
		if(player._x + PLAYER_RADIUS > FRAME_RIGHT)
			player._x = FRAME_RIGHT - PLAYER_RADIUS;

		if(player._y + PLAYER_RADIUS > FRAME_BOTTOM)
			player._y = FRAME_BOTTOM - PLAYER_RADIUS;

		if(player._y - PLAYER_RADIUS < FRAME_TOP)
			loseGame();
	}

	//drawing functions -------------------------------------------------------------

	function drawPlayer(){
		ctx.beginPath();
	    ctx.arc(player._x, player._y, PLAYER_RADIUS, 0, Math.PI*2, true);
	    ctx.closePath();

	    //CHANGE SIZE OF BALL HERE
	    ctx.drawImage(thumbImg, player._x-17, player._y-18, 34, 34);

		//RED RADIAL GRADIENT BELOW
		/*ctx.beginPath();
		ctx.arc(player._x, player._y, PLAYER_RADIUS, 0, Math.PI*2, true);
		ctx.closePath();

		var grd = ctx.createRadialGradient(player._x, player._y, 1, player._x, player._y, 30);


		grd.addColorStop(0, "#FF0000");
		grd.addColorStop(1, "#7F0000");

		ctx.fillStyle = grd;
		ctx.fill();
		ctx.strokeStyle = "#FF0000";
		ctx.stroke();*/
	}

	function drawScore(){
		ctx.font = "22pt Times";
		ctx.textAlign = "right";
		ctx.fillStyle = "#FFFFFF";
		// ctx.fillText(Math.floor(elapsedFrames) +"               Gratii: +" + Math.floor(elapsedFrames*.005), 305, 30);
		ctx.fillText(Math.floor(elapsedFrames), 305, 30);

	}


	/* for each bar, determine if the top or bottom needs to be cut off
	 * because it's at an edge of the screen, then call drawBar
	*/
	function drawBars(){

		for(var i = 0; i < NUM_BARS; i++){
			var topCutoff = 0;
			var bottomCutoff = 0;
			if(bars[i]._y < FRAME_TOP){
				topCutoff = FRAME_TOP - bars[i]._y;
				if(topCutoff > BAR_HEIGHT)
					topCutoff = BAR_HEIGHT;
			}

			if(bars[i]._y + BAR_HEIGHT > FRAME_BOTTOM){
				bottomCutoff = bars[i]._y + BAR_HEIGHT - FRAME_BOTTOM;
				if(bottomCutoff > BAR_HEIGHT)
					bottomCutoff = BAR_HEIGHT;
			}
			drawBar(bars[i], topCutoff, bottomCutoff);
		}
	}

	// because each bar has multiple gaps, use a loop to draw each segment.
	function drawBar(bar, topCutoff, bottomCutoff){

		var leftX = 0;
		//var rightX = 0;
		//for each gap, draw the segment of the bar before it
		for(var i = 0; i < bar.gaps.length; i++){
			rightX = bar.gaps[i].startPos;
			drawBarSegment(bar, leftX, rightX, topCutoff, bottomCutoff);
			leftX = bar.gaps[i].endPos;
		}
		rightX = BAR_WIDTH;

		//draw the rest of the bar to the end
		drawBarSegment(bar, leftX, rightX, topCutoff, bottomCutoff);
	}

	function drawBarSegment(bar, leftX, rightX, topCutoff, bottomCutoff){
		//console.log("drawing bar segment from " + leftX + " to " + rightX);

		var topLeftCornerX = leftX;
		var topLeftCornerY = bar._y + topCutoff;
		var width = rightX - leftX;
		var height = BAR_HEIGHT - (topCutoff + bottomCutoff);

		ctx.drawImage(barImage, 0, 0, width, 20, topLeftCornerX, topLeftCornerY, width, height);
	};

	function drawOrientationScreen(){

		ctx.fillStyle = "rgba(200, 200, 200, 0.3)";
		ctx.beginPath();
		ctx.rect(0, 0, canvas.width, canvas.height);
		ctx.fill();
		ctx.font = "bold 40pt Calibri";
		ctx.fillStyle = '#000000';
		ctx.fillText("This game must be played in portrait.", 0, canvas.height/2);

	};

	//this function causes the player to fall due to gravity, and also moves the bars up.
	function falling(){

		var oldPlayerY = player._y;

		player.y_velocity += player.y_acceleration;
		player._y += player.y_velocity*SCALING_CONSTANT*clockTick;

		for(var i = 0; i < NUM_BARS; i++){
			var oldBarY = bars[i]._y;
			bars[i]._y -= barSpeed*SCALING_CONSTANT*clockTick;

			//collision detection between the bar and the player
			if(oldPlayerY + PLAYER_RADIUS <= oldBarY && player._y + PLAYER_RADIUS >= bars[i]._y){
				if(playerInGap(bars[i]) < 0){
					player._y = bars[i]._y - PLAYER_RADIUS;
					player.y_velocity = 0;
				}
			}

			//if the bar goes offscreen, make it reappear at the bottom with new gaps
			if(bars[i]._y < FRAME_TOP - BAR_HEIGHT){
				bars[i]._y = bars[bottomBarIndex]._y + increment;
				bottomBarIndex = i;
				generateGaps(bars[i]);
			}

		}

		//increase the bar speed as time passes
		barSpeed = BASE_BAR_SPEED + elapsedFrames*BAR_SPEED_INCREASE_RATE;
		if(barSpeed > MAX_BAR_SPEED)
			barSpeed = MAX_BAR_SPEED;
	}

	//utility function; if the player's x position is currently entirely contained in
	//one of the bar's gaps, returns that gap's index. otherwise returns -1
	function playerInGap(bar){
		for(var j = 0; j < bar.gaps.length; j++){
			if(bar.gaps[j].startPos <= player._x - PLAYER_RADIUS - FRAME_LEFT &&
			   bar.gaps[j].endPos >= player._x + PLAYER_RADIUS - FRAME_LEFT){
				   return j;
			}
		}
		return -1;
	}

	function loseGame(){
		gameOver = true;
		console.log("bar speed: " + barSpeed + " elapsed frames: " + elapsedFrames);
		

		var finalScore = Math.floor(elapsedFrames);
		var scoreForThisEvent = finalScore;
		// CALL NEW GAME OVER FUNCTION HERE.. Be prepared to handle errors if no session exists and/or game is not being played inside of Gratii Arcade (i.e. Stand Alone Demo)
		if(parent.user.challengeIssueInProgress===true){
			// Deliver challenge issue, return var to false

			parent.user.deliverChallenge(scoreForThisEvent);
		}else if(parent.user.challengeResponseInProgress===true){
			// Deliver challenge response, return var to false

			parent.user.deliverChallengeResponse(scoreForThisEvent);
		}else{
			//Offer Play Again option
			var thisGameID = parent.user.gameInProgress['gameID'];
			var equations = parent.user.gameInProgress['equations'];
			var equationForGameOver = equations.gameOver;
			var thisGameEvent = "gameOver";
			var gratiiEarned = Math.floor(scoreForThisEvent*equationForGameOver);

			parent.user.changeGratii(gratiiEarned);

			parent.user.arcadeEvents.push({"gameToken":gameToken, "finalScore":scoreForThisEvent, "eventName":thisGameEvent, "gameID":thisGameID});
			parent.user.postGameEvents();
			
			window.setTimeout(function(){
				var playAgainAlert = confirm("Game over :(\nPlay again?"); 
				if (playAgainAlert==true){
			 		location.reload();
				}else{
			  		parent.closeGameiFrame();
				}
			}, 1500);
			
		}
		
		//parent.arcade.falling.gameOver(gameToken, finalScore);
	}

	function render(){
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		drawPlayer();
		drawBars();
		drawScore();
	}

	function updateGameState(){
		falling();
		keyInput();
		elapsedFrames++;
	}

	function mainLoop(){
		if(currentOrientation != 0){
			drawOrientationScreen();
		}
		else if(!gameOver){
			clockTick = timer.tick();
			updateGameState();
			render();
		}
	}

	// shim layer with setTimeout fallback
    window.requestAnimFrame = (function(){
      return  window.requestAnimationFrame       ||
              window.webkitRequestAnimationFrame ||
              window.mozRequestAnimationFrame    ||
              window.oRequestAnimationFrame      ||
              window.msRequestAnimationFrame     ||
              function(callback){
                window.setTimeout(callback, 1000 / 60);
              };
    })();


    // usage:
    // instead of setInterval(render, 16) ....

    (function animloop(){
		//if(!gameOver)
			requestAnimFrame(animloop);
		mainLoop();
    })();
};
};